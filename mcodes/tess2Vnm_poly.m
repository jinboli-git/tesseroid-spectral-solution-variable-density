function Vnm = tess2Vnm_poly(lon, lat, r1, r2, rho, nmax, opt)
%{
    This function calculates the potential coefficients generated by
    tesseroids with polynomial radially variable density
Input:
    lon: the longitude vector of the center of tesseroids [deg]
    lat: the latitude vector of the center of tesseroids [deg]
    r1: lower boundary of tesseroids [m]
    r2: upper boundary of tesseroids [m]
    rho: (:, :, s) is polynomial coefficients: rhos,  rho(r) = Sum_{s=0} rho_s * (r - r0)^s.
    nmax: maximum computational harmonic degree/order
    opt
    ::
    M: scaling constant of mass [m^3 kg^-1 s^-2]
    a: scaling constant of radius [m]
    szm: [Latitude dimension, longitude dimension] of tesseroids [deg]
    r0: reference radius of density function [m]
Return:
    Vnm: (:, 4) [n, m, C, S] potential coefficients
%}

arguments
    lon (1, :)
    lat (:, 1)
    r1 (:, :)
    r2 (:, :)
    rho (:, :, :)
    nmax (1, 1)
    opt.M (1, 1)
    opt.a (1, 1)
    opt.szm = [] % (1, 2)
    opt.r0 = 0;
end

nthe = length(lat);
nlam = length(lon);
P = size(rho, 3) - 1;

if isscalar(r1) 
    r1 = repmat(r1, nthe, nlam);
end
if isscalar(r2) 
    r2 = repmat(r2, nthe, nlam);
end
sz = size(rho);
if sz(1) == 1 && sz(2) == 1
    rho = repmat(rho, nthe, nlam, 1);
end

n = (0 : nmax)'; m = n;

if isempty(opt.szm)
    dlat = abs(lat(2) - lat(1));
    dlon = abs(lon(2) - lon(1));
else
    dlat = opt.szm(1);
    dlon = opt.szm(2);
end

costhe2 = cosd( min(180, 90 - lat + dlat / 2) );
costhe1 = cosd( max(0, 90 - lat - dlat / 2) );

Emj = 2 * sind(m / 2 * dlon) ./ m .* (cosd(m .* lon) + 1i * sind(m .* lon));
Emj(1, :) = deg2rad(dlon);
Emj = Emj.';

Qnm = zeros((nmax + 2) * (nmax + 1) / 2, 1, 'like', 1 + 1i);
Vnm = Qnm;

r1 = (r1 - opt.r0) / opt.a; r2 = (r2 - opt.r0) / opt.a;
r0 = opt.r0 / opt.a;

for i = 1 : nthe
    wn = zeros(nmax + 1, nlam);
    r1i = r1(i, :); r2i = r2(i, :);
    rhoi = squeeze(rho(i, :, :)).';
    for p = 0 : P
        wnp = zeros(nmax + 1, nlam);
        for b = 0 : nmax + 2
            inx = max(1, b - 1);
            nb = n(inx : end);
            wnp(inx : end, :) = wnp(inx : end, :) + (r2i .^ (p + b + 1) - r1i .^ (p + b + 1)) / (p + b + 1) .* (r0 .^ (nb + 2 - b) .* Cnk(nb + 2, b));
        end
        wnp = wnp .* rhoi(p + 1, :);
        if p > 3
            B = realmin;
            t = repmat(opt.a, p, 1);
            t(1) = t(1) * B;
            wnp = wnp * prod(t, 1) / B;
        else
            wnp = wnp * opt.a ^ p;
        end
        wn = wn + wnp;
    end
    inds = 1;
    wn = wn * Emj;
    for nn = 0 : nmax
        inde = inds + nn;
        Qnm(inds : inde) = wn(nn + 1, 1 : nn + 1);
        inds = inde + 1;
    end
    Qnm = Qnm .* IPnm(nmax, costhe1(i), costhe2(i));
    Vnm = Vnm + Qnm;
end

[n, m] = creat_nm(nmax);
Vnm = Vnm ./ (2 * n + 1) * (opt.a ^ 3 / opt.M);
Vnm = [n, m, real(Vnm), imag(Vnm)];

end
