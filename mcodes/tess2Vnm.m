function Vnm = tess2Vnm(lon, lat, r1, r2, rho, nmax, opt)
%{
    This function calculates the potential coefficients generated by tesseroids with constant density
Input:
    lon: the longitude vector of the center of tesseroids [deg]
    lat: the latitude vector of the center of tesseroids [deg]
    r1: lower boundary of tesseroids [m]
    r2: upper boundary of tesseroids [m]
    rho: densities of tesseroids [kg m^-3]
    nmax: maximum computational harmonic degree/order
    opt
    ::
    M: scaling constant of mass [m^3 kg^-1 s^-2]
    a: scaling constant of radius [m]
    szm: [Latitude dimension, longitude dimension] of tesseroids [deg] 
Return:
    Vnm: (:, 4) [n, m, C, S] potential coefficients
Reference:
    Šprlák M, Han S-C, Featherstone WE (2018) Forward modelling of global gravity fields with 3D density structures and an application to the high-resolution (~ 2 km) gravity fields of the Moon. J Geod 92:847–862. https://doi.org/10.1007/s00190-017-1098-7
Changelog:
    Written by Jinbo Li 2022/04/19
%}

arguments
    lon (1, :)
    lat (:, 1)
    r1 (:, :)
    r2 (:, :)
    rho (:, :)
    nmax (1, 1)
    opt.M (1, 1)
    opt.a (1, 1)
    opt.szm = [] % (1, 2)
end

nthe = length(lat);
nlam = length(lon);

if isscalar(r1) 
    r1 = repmat(r1, nthe, nlam);
end
if isscalar(r2) 
    r2 = repmat(r2, nthe, nlam);
end
if isscalar(rho) 
    rho = repmat(rho, nthe, nlam);
end
r1 = r1 / opt.a;
r2 = r2 / opt.a;

n = (0 : nmax)'; m = n;

if isempty(opt.szm)
    dlat = abs(lat(2) - lat(1));
    dlon = abs(lon(2) - lon(1));
else
    dlat = opt.szm(1);
    dlon = opt.szm(2);
end

costhe2 = cosd( min(180, 90 - lat + dlat / 2) );
costhe1 = cosd( max(0, 90 - lat - dlat / 2) );

Emj = 2 * sind(m / 2 * dlon) ./ m .* (cosd(m .* lon) + 1i * sind(m .* lon));
Emj(1, :) = deg2rad(dlon);
Emj = Emj.';

Qnm = zeros((nmax + 2) * (nmax + 1) / 2, 1, 'like', 1 + 1i); 
Vnm = Qnm;

for i = 1 : nthe
    wn = rho(i, :) .* (r2(i, :) .^ (n + 3) - r1(i, :) .^ (n + 3));
    inds = 1;
    wn = wn * Emj;
    for nn = 0 : nmax
        inde = inds + nn;
        Qnm(inds : inde) = wn(nn + 1, 1 : nn + 1);
        inds = inde + 1;
    end
    Vnm = Vnm + Qnm .* IPnm(nmax, costhe1(i), costhe2(i));
end

[n, m] = creat_nm(nmax);
Vnm = Vnm ./ (2 * n + 1) ./ (n + 3) * (opt.a ^ 3 / opt.M);
Vnm = [n, m, real(Vnm), imag(Vnm)];

end