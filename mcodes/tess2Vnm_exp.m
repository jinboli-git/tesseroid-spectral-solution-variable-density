function Vnm = tess2Vnm_exp(lon, lat, r1, r2, rho, nmax, opt)
%{
    This function calculates the potential coefficients generated by
    tesseroids with exponential radially variable density
Input:
    lon: the longitude vector of the center of tesseroids [deg]
    lat: the latitude vector of the center of tesseroids [deg]
    r1: lower boundary of tesseroids [m]
    r2: upper boundary of tesseroids [m]
    rho: (:, :, 1) is rho0, and (:, :, 2) is mu. rho(r) = rho0 * exp(-u * (r - r0))
    nmax: maximum computational harmonic degree/order
    opt
    ::
    M: scaling constant of mass [m^3 kg^-1 s^-2]
    a: scaling constant of radius [m]
    szm: [Latitude dimension, longitude dimension] of tesseroids [deg]
    r0: reference radius of density function [m]
Return:
    Vnm: (:, 4) [n, m, C, S] potential coefficients
%}

arguments
    lon (1, :)
    lat (:, 1)
    r1 (:, :)
    r2 (:, :)
    rho (:, :, 2)
    nmax (1, 1)
    opt.M (1, 1)
    opt.a (1, 1)
    opt.szm = [] % (1, 2)
    opt.r0 (1, 1) = 0;
end

nthe = length(lat);
nlam = length(lon);

if isscalar(r1) 
    r1 = repmat(r1, nthe, nlam);
end
if isscalar(r2) 
    r2 = repmat(r2, nthe, nlam);
end
if isscalar(rho(:, :, 2)) 
    mu = repmat(rho(:, :, 2), nthe, nlam);
end
if isscalar(rho(:, :, 1)) 
    rho = repmat(rho(:, :, 1), nthe, nlam);
end

n = (0 : nmax)'; m = n;

if isempty(opt.szm)
    dlat = abs(lat(2) - lat(1));
    dlon = abs(lon(2) - lon(1));
else
    dlat = opt.szm(1);
    dlon = opt.szm(2);
end

costhe2 = cosd( min(180, 90 - lat + dlat / 2) );
costhe1 = cosd( max(0, 90 - lat - dlat / 2) );

Emj = 2 * sind(m / 2 * dlon) ./ m .* (cosd(m .* lon) + 1i * sind(m .* lon));
Emj(1, :) = deg2rad(dlon);
Emj = Emj.';

Qnm = zeros((nmax + 2) * (nmax + 1) / 2, 1, 'like', 1 + 1i); 
Vnm = Qnm;

et1 = exp(-mu .* (r1 - opt.r0)); et2 = exp(-mu .* (r2 - opt.r0));
r1 = r1 / opt.a; r2 = r2 / opt.a;
mu = mu * opt.a;

for i = 1 : nthe
    wn = zeros(nmax + 1, nlam);
    et1i = et1(i, :); et2i = et2(i, :); 
    r1i = r1(i, :); r2i = r2(i, :);
    mui = mu(i, :);
    for b = 0 : nmax + 2
        inx = max(1, b - 1);
        nb = n(inx : end);
        t = et1i .* r1i .^ (nb + 2 - b) - et2i .* r2i .^ (nb + 2 - b);
        p = gammaln(nb + 3) - gammaln(nb + 3 - b) - (b + 1) * log(mui);
        wn(inx : end, :) = wn(inx : end, :) + t .* exp(p);
    end
    wn = wn .* rho(i, :);
    inds = 1;
    wn = wn * Emj;
    for nn = 0 : nmax
        inde = inds + nn;
        Qnm(inds : inde) = wn(nn + 1, 1 : nn + 1);
        inds = inde + 1;
    end
    Qnm = Qnm .* IPnm(nmax, costhe1(i), costhe2(i));
    Vnm = Vnm + Qnm;
end

[n, m] = creat_nm(nmax);
Vnm = Vnm ./ (2 * n + 1) * (opt.a ^ 3 / opt.M);
Vnm = [n, m, real(Vnm), imag(Vnm)];

end