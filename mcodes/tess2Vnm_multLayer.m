function Vnm = tess2Vnm_multLayer(lon, lat, r1, r2, fun_rho, nmax, opt)
%{
    This function calculates the potential coefficients generated by
    tesseroids with variable density by assumeing homogeneous tesseroids
    but allows density variations between tesseroids. The radially variable
    density is treated by layering.
Input:
    lon: the longitude vector of the center of tesseroids [deg]
    lat: the latitude vector of the center of tesseroids [deg]
    r1: lower boundary of tesseroids [m]
    r2: upper boundary of tesseroids [m]
    fun_rho: a function handle to calculate the density frho(r) in [kg m^-3]
    nmax: maximum computational harmonic degree/order
    opt
    ::
    M: scaling constant of mass [m^3 kg^-1 s^-2]
    a: scaling constant of radius [m]
    szm: [Latitude dimension, longitude dimension] of tesseroids [deg]
    dd: the thickness of a single layer of tesseroid in an equal-thickness
    layering [m]
    maxLayerNum: Maximum number of layers
Return:
    Vnm: (:, 4) [n, m, C, S] potential coefficients
Reference:
    Šprlák M, Han S-C, Featherstone WE (2018) Forward modelling of global gravity fields with 3D density structures and an application to the high-resolution (~ 2 km) gravity fields of the Moon. J Geod 92:847–862. https://doi.org/10.1007/s00190-017-1098-7
%}

arguments
    lon (1, :)
    lat (:, 1)
    r1 (:, :)
    r2 (:, :)
    fun_rho
    nmax (1, 1)
    opt.M (1, 1)
    opt.a (1, 1)
    opt.szm = [] % (1, 2)
    opt.dd = 100;
    opt.maxLayerNum (1, 1) = 101;
end

nthe = length(lat);
nlam = length(lon);
dd = opt.dd;

if isscalar(r1)
    r1 = repmat(r1, nthe, nlam);
end
if isscalar(r2)
    r2 = repmat(r2, nthe, nlam);
end
if isscalar(dd)
    dd = sign(r2 - r1) * dd;
end

n = (0 : nmax)'; m = n;

if isempty(opt.szm)
    dlat = abs(lat(2) - lat(1));
    dlon = abs(lon(2) - lon(1));
else
    dlat = opt.szm(1);
    dlon = opt.szm(2);
end

costhe2 = cosd( min(180, 90 - lat + dlat / 2) );
costhe1 = cosd( max(0, 90 - lat - dlat / 2) );

Emj = 2 * sind(m / 2 * dlon) ./ m .* (cosd(m .* lon) + 1i * sind(m .* lon));
Emj(1, :) = deg2rad(dlon);
Emj = Emj.';

Qnm = zeros((nmax + 2) * (nmax + 1) / 2, 1, 'like', 1 + 1i);
Vnm = Qnm;

for i = 1 : nthe
    wn = zeros(nmax + 1, nlam);
    r1i = r1(i, :); r2i = r2(i, :); ddi = dd(i, :);
    r1ik = r1i;
    for k = 1 : opt.maxLayerNum
        if k == opt.maxLayerNum
            r2ik = r2i;
        else
            r2ik = min(r2i, r1ik + ddi);
        end
        rho = (fun_rho(r1ik) + fun_rho(r2ik)) / 2;
        wn = wn + rho .* ((r2ik / opt.a) .^ (n + 3) - (r1ik / opt.a) .^ (n + 3));
        r1ik = r2ik;
    end
    inds = 1;
    wn = wn * Emj;
    for nn = 0 : nmax
        inde = inds + nn;
        Qnm(inds : inde) = wn(nn + 1, 1 : nn + 1);
        inds = inde + 1;
    end
    Qnm = Qnm .* IPnm(nmax, costhe1(i), costhe2(i));
    Vnm = Vnm + Qnm;
end

[n, m] = creat_nm(nmax);
Vnm = Vnm ./ (2 * n + 1) ./ (n + 3) * (opt.a ^ 3 / opt.M);
Vnm = [n, m, real(Vnm), imag(Vnm)];

end