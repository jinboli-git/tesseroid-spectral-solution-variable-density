function Vnm = tess2Vnm_glq(lon, lat, r1, r2, fun_rho, nmax, opt)
%{
    This function calculates the potential coefficients generated by
    tesseroids with general radius density by adaptive Gaussian quadrature.
Input:
    lon: the longitude vector of the center of tesseroids [deg]
    lat: the latitude vector of the center of tesseroids [deg]
    r1: lower boundary of tesseroids [m]
    r2: upper boundary of tesseroids [m]
    frho: a function handle to calculate the density frho(r) in [kg m^-3]
    nmax: maximum computational harmonic degree/order
    opt
    ::
    M: scaling constant of mass [m^3 kg^-1 s^-2]
    a: scaling constant of radius [m]
    szm: [Latitude dimension, longitude dimension] of tesseroids [deg]
    Nq: the number of quadrature nodes, if is empty, the automatic determination.
Return:
    Vnm: (:, 4) [n, m, C, S] potential coefficients
Changelog:
    Written by Jinbo Li 2024/10/19
%}

arguments
    lon (1, :)
    lat (:, 1)
    r1 (:, :)
    r2 (:, :)
    fun_rho % function handle
    nmax (1, 1)
    opt.M (1, 1)
    opt.a (1, 1)
    opt.szm = [] % (1, 2)
    opt.Nq = [];
end

nthe = length(lat);
nlam = length(lon);

if isscalar(r1)
    r1 = repmat(r1, nthe, nlam);
end
if isscalar(r2)
    r2 = repmat(r2, nthe, nlam);
end
r0 = (r1 + r2) / 2;
dr = (r2 - r1) / 2;

n = (0 : nmax)'; m = n;

if isempty(opt.Nq)
    opt.Nq = max(best_Nq(r0, dr, fun_rho));
end
[nd, W] = glnw(opt.Nq, -1, 1);
Nd = length(nd);

if isempty(opt.szm)
    dlat = abs(lat(2) - lat(1));
    dlon = abs(lon(2) - lon(1));
else
    dlat = opt.szm(1);
    dlon = opt.szm(2);
end

costhe2 = cosd( min(180, 90 - lat + dlat / 2) );
costhe1 = cosd( max(0, 90 - lat - dlat / 2) );

Emj = 2 * sind(m / 2 * dlon) ./ m .* (cosd(m .* lon) + 1i * sind(m .* lon));
Emj(1, :) = deg2rad(dlon);
Emj = Emj.';

Qnm = zeros((nmax + 2) * (nmax + 1) / 2, 1, 'like', 1 + 1i);
Vnm = Qnm;

for i = 1 : nthe
    wn = zeros(nmax + 1, nlam);
    r0i = r0(i, :);
    dri = dr(i, :);
    for k = 1 : Nd
        rk = dri * nd(k) + r0i;
        wn = wn + W(k) * fun_rho(rk) .* (rk / opt.a) .^ (n + 2);
    end
    inds = 1;
    wn = (wn .* dri) * Emj;
    for nn = 0 : nmax
        inde = inds + nn;
        Qnm(inds : inde) = wn(nn + 1, 1 : nn + 1);
        inds = inde + 1;
    end
    Qnm = Qnm .* IPnm(nmax, costhe1(i), costhe2(i));
    Vnm = Vnm + Qnm;
end

[n, m] = creat_nm(nmax);
Vnm = Vnm ./ (2 * n + 1) * (opt.a ^ 2 / opt.M);
Vnm = [n, m, real(Vnm), imag(Vnm)];

end

%% subroutine
function [x,w] = glnw(N, a, b)
% This script is for computing definite integrals using Legendre-Gauss 
% Quadrature. Computes the Legendre-Gauss nodes and weights  on an interval
% [a,b] with truncation order N
%
% Suppose you have a continuous function f(x) which is defined on [a,b]
% which you can evaluate at any x in [a,b]. Simply evaluate it at all of
% the values contained in the x vector to obtain a vector f. Then compute
% the definite integral using sum(f.*w);
%
% Written by Greg von Winckel - 02/25/2004
% (https://ww2.mathworks.cn/matlabcentral/fileexchange/4540-legendre-gauss-quadrature-weights-and-nodes), MATLAB Central File Exchange.
arguments
    N (1, 1)
    a (1, 1) = -1
    b (1, 1) = 1
end
N = N - 1;
N1 = N + 1; N2 = N + 2;
xu = linspace(-1, 1, N1)';
% Initial guess
y = cos((2 * (0:N)' + 1) * pi / (2 * N + 2)) + (0.27 / N1) * sin(pi * xu * N / N2);
% Legendre-Gauss Vandermonde Matrix
L = zeros(N1, N2);
% Derivative of LGVM
Lp = zeros(N1, N2);
% Compute the zeros of the N+1 Legendre Polynomial
% using the recursion relation and the Newton-Raphson method
y0 = 2;
% Iterate until new points are uniformly within epsilon of old points
while max(abs(y - y0)) > eps
    L(:, 1) = 1;
    L(:, 2) = y;
    for k = 2:N1
        L(:, k + 1) = ( (2 * k - 1) * y .* L(:, k) - (k - 1) * L(:, k - 1) ) / k;
    end
    Lp = (N2) * ( L(:, N1) - y .* L(:, N2) ) ./ (1 - y .^ 2);
    y0 = y;
    y = y0 - L(:, N2) ./ Lp;
end

% Linear map from[-1,1] to [a,b]
x = (a * (1 - y) + b * (1 + y)) / 2;

% Compute the weights
w = (b - a) ./ ((1 - y .^ 2) .* Lp .^ 2) * (N2 / N1) ^ 2;

end

function Nq = best_Nq(r0, dr, frho)

numts = 25;
[row, col] = size(r0);
vv = zeros(numts, col);
Nq = zeros(row, 1);
for i = 1 : row
    r0i = r0(i, :); dri = dr(i, :);
    for nq = 1 : numts
        t = 0;
        [nd, w] = glnw(nq, -1, 1);
        for k = 1 : nq
            rk = dri * nd(k) + r0i;
            t = t + w(k) * frho(rk) .* rk .^ 2;
        end
        vv(nq + 1, :) = t;
        rerr = max(abs((t - vv(nq, :)) ./ t));
        if rerr <= 1e-13
            break;
        end
    end
    Nq(i) = nq;
end

Nq(Nq < 4) = 4;

end